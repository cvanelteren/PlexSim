* Banner animation
** Setup
#+begin_src jupyter-python
from plexsim.models import *
import networkx as nx, numpy as np

n = 32
g = nx.grid_graph([n, n])

nx.set_node_attributes(g, {node: 0 for node in g.nodes()}, "state")
idx = np.random.randint(len(list(g.nodes())))

node = list(g.nodes())[idx]
rule = nx.cycle_graph(5)
from plexsim.utils.rules import create_rule_full

rule = create_rule_full(rule, self_weight=-10, connection_weight_other = -10)

settings = dict(
    graph=g,
    updateType="async",
)

import time

ti = time.time()

bounds = np.array([0., 50.])
max_speed = 4
coordinates = np.random.rand(120, 2) * max(bounds)
velocities = np.random.randn(120, 2) * max_speed
S = np.arange(0, len(rule))
models = dict(
    Potts=Potts(t=0.8, agentStates=np.arange(0, 5), **settings),
    Bonabeau=Bonabeau(agentStates=np.arange(3), eta=0, **settings),
    AB=AB(**settings),
    Prisoner=Prisoner(**settings),
    Ising=Ising(t=2.2, **settings),
    Bornholdt=Bornholdt(t=2.2, alpha=4, **settings),
    RBN=RBN(**settings),
    SIRS=SIRS(mu=0.15, nu=0, kappa=0.01, beta=0.4, **settings),
    CCA=CCA(agentStates=np.arange(0, 4).tolist(), threshold=0.01, **settings),
    Percolation=Percolation(p=0.01, **settings),
    MagneticBoids=MagneticBoids(
        coordinates=coordinates,
        velocities=velocities,
        rules=rule,
        bounded_rational=4,
        max_speed = max_speed,
        agentStates=S,
        bounds = bounds,
        radius= 3,
        t = 1.0,
        boid_radius = 1,
        dt = .5,
        # sampleSize = 1,
    ),
    Rock_Paper_Scissor=Cycledelic(g, predation=2.0, competition=1.5, difusion=0.68),
)
print(f"Settup time was {time.time() - ti}")
# models.get("Bornholdt").sampleSize = 1
if m := models.get("SIRS"):
    m.states = 0
    m.states[m.sampleNodes(1)[0, 0]] = 1

if m := models.get("SIR"):
    m.states = 0
    m.states[m.sampleNodes(1)[0, 0]] = 1


if m := models.get("Percolation"):
    m.states = 0
    m.states[m.sampleNodes(1)[0, 0]] = 1
print("starting sims")

# mi = list(models.values())
# for i in mi:
#     print(i.memory.shape, i.memento)
# assert 0
T = 1000
import time

start = time.time()

results = {}
import copy
for idx, (name, m) in enumerate(models.items()):
    #     m.states = m.agentStates[-1]
    # m.reset()
    if name == "MagneticBoids":
        ri = np.zeros(T, dtype = object)
        for i in range(T):
            m.updateState(m.sampleNodes(1)[0])
            ri[i] = [m.adj.adj.copy(), m.states.copy(),
                     m.coordinates.copy()]
            
        results[name] = ri
    else:
        results[name] = m.simulate(T)
        
print(f"Simulation took {time.time() - start}")
#+end_src

#+RESULTS:
: Settup time was 0.12779021263122559
: starting sims
: Simulation took 6.897793531417847

#+begin_src jupyter-python
a = results["MagneticBoids"][0][-1]
b = results["MagneticBoids"][100][-1]

print(len(results["MagneticBoids"][-1][0][0]['neighbors']))
print(len(results["MagneticBoids"][0][0][0]['neighbors']))
print((a == b).sum(), a[0], b[1])
#+end_src

#+RESULTS:
: 108
: 103
: 0 [37.41813538 42.6623588 ] [ 0.23132398 20.4059235 ]


** Animate
#+begin_src jupyter-python
from matplotlib import patches
from matplotlib.collections import LineCollection
def animate_boids(idx):
    theta = .2
    axi.cla()
    adj, states, coordinates = results[name][idx]
    ci = states.astype(int)

    colors = cmr.pride(np.linspace(0, 1, len(rule), 0))
    ci = colors[ci]
    # pos = {idx: ci for idx, ci in enumerate(m.coordinates)}
    adj = {k: v["neighbors"] for k, v in adj.items()}
    g = nx.from_dict_of_lists(adj)
    lc = np.array([[coordinates[x], coordinates[y]] for x, y in g.edges()])
    lc = LineCollection(lc, color="lightgray", zorder=1, alpha=0.7,
                        )
    axi.add_collection(lc)

    boundary = patches.Rectangle(
        (m.bounds[0], m.bounds[0]),
        m.bounds[1] - m.bounds[0],
        m.bounds[1] - m.bounds[0],
        facecolor="none",
        alpha=0.1,
        edgecolor="k",
        lw=5,
        zorder=1,
    )
    # [ax.spines[i].set_visible(True) for i in "left top right bottom".split()]
    axi.add_patch(boundary)
    axi.scatter(*coordinates.T, c=ci, zorder=5, s= m.boid_radius * 60)
    axi.annotate(
        f"t = {idx}",
        (0, 1),
        xycoords="axes fraction",
        va="bottom",
        ha="left",
        zorder=5,
        fontsize=30,
    )
    axi.set_xlabel("x")
    axi.set_ylabel("y")
    
    axi.annotate(name.replace("_", " "), (.5, 1.2),
                    xycoords = "axes fraction",
                    color=C,
                    fontsize = 27,
                    ha = 'center',
                    va = 'bottom')
    axi.axis("off")

    bounds = m.bounds
    # axi.set_xlim(min(bounds) * 1 - theta, max(bounds) * (1 + theta))
    # axi.set_ylim(min(bounds) * 1 - theta, max(bounds) * (1 + theta))
    axi.axis("equal")

import matplotlib.pyplot as plt
from ipywidgets import interact, IntSlider
import matplotlib as mpl
from mpl_toolkits.axes_grid1 import make_axes_locatable as mal
import cmasher as cmr
from plexsim.utils.visualisation import GraphAnimation

plt.style.use("spooky")

columns, rows = divmod(len(models), 2)
columns, rows = 6, 2
# columns = columns + 1 if not columns else columns
# rows = rows + 1 if not rows else rows
layout = np.zeros(len(models), dtype=object)
for idx, c in enumerate(models):
    layout[idx] = c
layout = layout.reshape(2, 6)
# layout = layout.reshape(-1, 1)
fig = plt.figure(figsize=(20, 18), constrained_layout=1)
ax = fig.subplot_mosaic(layout)
# setup figure/
hs = {}
pad = 0.01
size = "5%"

for name, axi in ax.items():
    m = models[name]
   
    # h = axi.imshow(
    #     results[name][0], cmap=cmap, vmin=AS[0], vmax=AS[-1], interpolation=None
    # )
    C = "#485ea4"
    C = "gray"
    C = "#ADC3D1"

    AS = m.agentStates

    NS = len(AS)
    norm = plt.cm.colors.Normalize(vmin=min(AS), vmax=max(AS))
    cmap = mpl.colors.LinearSegmentedColormap.from_list(
            None, cmr.pride(np.linspace(0, 1, NS, endpoint=0)[:NS]), NS
        )

    sm = plt.cm.ScalarMappable(norm=norm, cmap=cmap)
    if name == "MagneticBoids":
        func = animate_boids
    else:
        div = mal(axi)
        cbr = div.append_axes("bottom", size=size, pad=pad)
        #     div = mal(cbr)
        #     cbr = div.append_axes('right', size = size, pad = pad)
       
        pos = {k: np.array(eval(k)) for k in m.graph.nodes()}
        l  ={k: "" for k in m.graph.nodes()}

        csg = GraphAnimation(m.graph, results[name], m.nStates)
        csg.setup(
            ax=axi,
            layout=pos,
             labels = dict(labels = l),
            node_kwargs = dict(node_size = 40)
        )
        func = csg.animate
                # axi.spines['bottom'].set_color('red')
        # axi.spines['top'].set_color('red')

        tmp = fig.colorbar(sm, cax=cbr, ticks=AS, orientation="horizontal")
        cbr.tick_params(colors=C)
        if name == "SIRS":
            tmp.set_ticklabels("Sus. Inf. Rec.".split())
            
    axi.annotate(name.replace("_", " "), (.5, 1.2),
                    xycoords = "axes fraction",
                    color=C,
                    fontsize = 27,
                    ha = 'center',
                    va = 'bottom')
    axi.axis("off")
    axi.axis("equal")

    hs[name] = func
mainax = fig.add_subplot(111, frameon=0, xticks=[], yticks=[])

text = mainax.annotate(
    "",
    (0.5, 0.05),
    xycoords="axes fraction",
    fontsize=40,
    ha="center",
    va="center",
    color=C,
)
# fig.subplots_adjust(left = 0, right = 1, bottom = 0, top = 1)

fig.subplots_adjust(wspace=0.02, hspace=0.2)
fig.tight_layout()
# fig.subplots_adjust(hspace = -.2)


def update(t):
    global m, name, axi
    for name, h in hs.items():
        m = models[name]
        axi = ax[name]
        h(t)
        # h.set_data(results[name][t])
            # h.autoscale()
    text.set_text(f"T = {t:03d}")
    fig.canvas.flush_events()
    fig.canvas.draw()
    return hs.values()


# fig.subplots_adjust(wspace = .02, hspace = .0)
from matplotlib.animation import FuncAnimation as FA

anim = FA(
    fig,
    update,
    frames=np.linspace(0, T, 200, endpoint=0).astype(int),
)
anim.save(
    "./new_banner2.webm",
    fps=30,
    # dpi=150,
    # writer="ffmpeg",
    # savefig_kwargs=dict(bbox_inches="tight", facecolor="#16161D"),
)
print("done")
#+end_src

#+RESULTS:
: <ipython-input-18-88ba6fde2e7a>:64: UserWarning: Style includes a parameter, 'backend', that is not related to style.  Ignoring
:   plt.style.use("spooky")
: <ipython-input-18-88ba6fde2e7a>:151: UserWarning: This figure was using constrained_layout, but that is incompatible with subplots_adjust and/or tight_layout; disabling constrained_layout.
:   fig.subplots_adjust(wspace=0.02, hspace=0.2)



